<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="style1.css">
</head>
<body>
    <header>
       <h1>МДК.07.01  Управление и автоматизация баз данных</h1> 
    </header>
    <div class="cont">
    <div class="item1 card">
    <ol>
        <li><a href="1t.html">Аутентификация соединений с сервером Авторизация логинов для подключения к базам данных</a></li>
        <li><a href="2t.html">Требования безопасности к серверам баз данных. Классы защиты</a></li>
        <li><a href="3t.html">Работа с ролями сервера Работа с фиксированными ролями базы данных/ Назначение пользовательских ролей базы данных</a></li>
        <li><a href="4t.html">Отчеты тестировании. Регрессионное и смоук-тестирование. Тестирование локализации.</a></li>
        <li><a href="5t.html">Анализ требований.</a></li>
        <li><a href="6t.html">Тест дизайн.</a></li>
        <li><a href="7t.html">Тестовая документация.</a></li>
        <li><a href="8t.html">Практическое занятие 1 Создание тестовой документации для сервиса</a></li>
        <li><a href="9t.html">Практическое занятие 2 Клиент-серверная архитектура. Веб-приложение. URL.</a></li>
        <li><a href="10t.html">Практическое занятие 3 Протоколы HTTP и HTTPS. Структура HTTP-запроса и ответа.</a></li>
        <li><a href="11t.html">Практическое занятие 4 Инструмент для работы с макетами. Элементы интерфейса: общие элементы, элементы ввода данных, элементы выбора данных, элементы действий</a></li>
        <li><a href="12t.html">Практическое занятие 5 Формы. Тестирование валидации. Тестирование текста на ошибки.</a></li>
        <li><a href="13t.html">Практическое занятие 6 Кроссплатформенное тестирование. Как понять, на каких ОС проверять приложение.</a></li>
        <li><a href="14t.html"></a></li>
        <li><a href="15t.html"></a></li>
        <li><a href="16t.html"></a></li>
        <li><a href="17t.html"></a></li>
        <li><a href="18t.html"></a></li>
        <li><a href="19t.html"></a></li>
    </ol></div>
    <div class="item2 card">
        <div class="card">
            <h2>Аутентификация соединений с сервером Авторизация логинов для подключения к базам данных</h2>
        </div>
        <div class="card">
            <h3>Аутентификация vs. Авторизация: Краткое различие</h3>
            <ul>
                <li><b>Аутентификация (Authentication - AuthN): </b>Процесс <b>проверки подлинности </b>пользователя. Ответ на вопрос <b>"Кто вы?"</b>. Это проверка логина/пароля, отпечатка пальца, Face ID и т.д.</li>
                <li><b>Авторизация (Authorization - AuthZ): </b>Процесс <b>проверки прав </b>прав пользователя на выполнение определенных действий. Ответ на вопрос <b>"Что вам разрешено делать?". </b> Это проверка ролей (админ, модератор, пользователь) и разрешений (может ли он читать, писать, удалять).</li>
            </ul>
            <p><b>Простая аналогия:</b></p>
            <ol>
                <li>Вы предъявляете паспорт на ресепшене отеля -> <b>Аутентификация </b> (доказали, что вы это вы).</li>
                <li>Вам выдают ключ от номера 505, но не от номера 506 -> <b>Авторизация</b> (определили, к чему у вас есть доступ).</li>
            </ol>
        </div>
        <div class="card">
            <h3>Часть 1: Аутентификация соединений с сервером</h3>
            <p>Здесь речь идет о том, как <b>ваше веб-приложение (клиент) </b>доказывает свою подлинность <b>серверу, </b>на котором работает backend. Это особенно важно для API.</p>
            <b>Распространенные методы аутентификации сервер-сервер или клиент-сервер:</b>
            <ol>
                <li><b>API Keys (Ключи API)</b></li>
                    <ul>
                        <li><b>Как работает: </b>Простой длинный уникальный токен, который клиент передает с каждым запросом (обычно в заголовке X-API-Key или как параметр запроса).</li>
                        <li><b>Плюсы: </b>Простота реализации и использование.</li>
                        <li><b>Минусы: </b>: Низкая безопасность. Ключ часто передается открыто, его компрометация дает полный доступ. <b>Никогда не используйте для аутентификации пользователей! </b>Подходит для аутентификации сервисов между собой в доверенной среде.</li>
                    </ul>
                <li><b>JWT (JSON Web Tokens)</b></li>
                    <ul>
                        <li><b>Как работает:</b></li>
                            <ol>
                                <li>Пользователь логинится (отправляет логин/пароль).</li>
                                <li>Сервер проверяет данные, создает <b>JWT-токен </b> (подписанный цифровой подписью) и отдает его клиенту.</li>
                                <li>Клиент сохраняет токен (часто в LocalStorage или Cookies) и передает его в заголовке Authorization: Bearer (токен) при каждом последующем запросе.</li>
                                <li>Сервер проверяет подпись токена и извлекает из него данные (например, user id). <b>Ему не нужно хранить сессию на сервере </b> (stateless).</li>
                            </ol>
                        <li><b>Плюсы: </b>Масштабируемость (не требует хранения сессий на сервере), удобство для мобильных и SPA-приложений.</li>
                        <li><b>Минусы: </b>Сложность с немедленной инвалидацией токена (пока не истечет его срок жизни).</li>
                    </ul>
                <li><b>OAuth 2.0 / OpenID Connect</b></li>
                    <ul>
                        <li><b>Как работает: </b>Делегированная аутентификация. Пользователь аутентифицируется на доверенном сервисе (например, Google, GitHub, Facebook), который затем выдает вашему приложению токен доступа.</li>
                        <li><b>Плюсы: </b>Пользователям не нужно создавать новый пароль. Высокий уровень безопасности, так как пароли обрабатываются крупными провайдерами.</li>
                        <li><b>Минусы: </b>Более сложная реализация на стороне backend.</li>
                    </ul>
                <li><b>Аутентификация на основе сессий (Cookies)</b></li>
                    <ul>
                        <li><b>Как работает:</b></li>
                            <ol>
                                <li>Пользователь логинится.</li>
                                <li>Сервер создает запись <b>сессии </b>в базе данных или in-memory хранилище (например, Redis) и отправляет клиенту идентификатор сессии <b>(Session ID) </b>в cookie (с флагами HttpOnly, Secure).</li>
                                <li>Браузер автоматически отправляет этот cookie с каждым запросом.</li>
                                <li>Сервер проверяет ID сессии в своем хранилище.</li>
                            </ol>
                        <li><b>Плюсы: </b>Простота инвалидации сессии (удалил запись — доступ закрыт). Безопаснее хранения JWT в LocalStorage.</li>
                        <li><b>Минусы: </b>Требует stateful-сервера и хранения сессий, что может усложнить масштабирование.</li>
                    </ul>
            </ol>
        </div>
        <div class="card">
            <h3>Часть 2: Авторизация логинов для подключения к базам данных</h3>
            <p>Здесь речь идет о том, как <b>ваше backend-приложение </b>подключается к <b>СУБД</b> (MySQL, PostgreSQL, MongoDB и т.д.). Это служебная, а не пользовательская авторизация.</p>
            <b>Ключевые принципы:</b>
            <ol>
                <li><b>Принцип наименьших привилегий (Principle of Least Privilege)</b></li>
                        <ul>
                            <li>Это золотое правило. Учетная запись, которую использует ваше приложение для подключения к БД, должна иметь <b>ровно те права, которые ей необходимы, и не более.</b></li>
                            <li><b>Пример: </b>Если ваше приложение только читает данные из таблицы articles, его пользователь БД должен иметь право только SELECT на эту таблицу, но не INSERT, UPDATE, DELETE или DROP.</li>
                         </ul>
                <li><b>Использование разных учетных записей для разных целей</b></li>
                        <ul>
                            <li>Не используйте одну супер-учетку (root/admin) для всего.</li>
                            <li>Создайте отдельного пользователя БД специально для вашего приложения.</li>
                            <li>Для разных сервисов (основное приложение, скрипты миграции, analytics) можно создать разных пользователей с разными правами.</li>
                        </ul>
                <li><b>Безопасное хранение учетных данных</b></li>
                <ul>
                        <li><b>Никогда не храните логины/пароли от БД в коде приложения (в гите)!</b></li>
                        <li><b>Используйте переменные окружения (Environment Variables) или секреты (Secrets):</b></li>
                            <ul>
                            <li>Локально: файл .env (который добавлен в .gitignore).</li>
                            <li>На продакшене: используйте механизмы вашего хостинга/платформы (Environment Variables в Heroku, Secrets в Kubernetes, AWS Secrets Manager, HashiCorp Vault).</li>
                            </ul>
                        <li>Пример для Node.js и .env:</li>
                        <p><b>bash</b></p>
                        <p># Файл .env</p>
                        <p>DB_HOST=localhost</p>
                        <p>DB_PORT=5432</p>
                        <p>DB_NAME=mydatabase</p>
                        <p>DB_USER=myapp_user</p>
                        <p>DB_PASSWORD=very_strong_password_123</p>
                        <p>javascript</p>
                        <p><b>// Код приложения</b></p>
                        <p>const { Pool } = require('pg');</p>
                        <p>const pool = new Pool({</p>
                        <p>host: process.env.DB_HOST,</p>
                        <p>port: process.env.DB_PORT,</p>
                        <p>database: process.env.DB_NAME,</p>
                        <p>user: process.env.DB_USER,</p>
                        <p>password: process.env.DB_PASSWORD,</p>
                        <p>});</p>
                </ul>
                <li><b>Использование SSL/TLS для подключения к БД</b></li>
                <ul>
                        <li>Особенно критично, если ваша БД находится на удаленном сервере (не на том же хосте, что и приложение).</li>
                        <li>Это шифрует весь трафик между приложением и СУБД, защищая данные от перехвата.</li>
                    </ul>
            </ol>
        </div>
        <div class="card">
            <h3>Итог: </h3>
            <p>Всегда разделяйте аутентификацию пользователей вашего приложения и аутентификацию самого приложения для доступа к БД. Для обоих случаев применяйте принцип наименьших привилегий и никогда не храните секреты в коде.</p>
        </div>
</div>
</div>
</body>
</html>